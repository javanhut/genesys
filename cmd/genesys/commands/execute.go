package commands

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/BurntSushi/toml"
	"github.com/javanhut/genesys/pkg/config"
	"github.com/javanhut/genesys/pkg/intent"
	"github.com/javanhut/genesys/pkg/lambda"
	"github.com/javanhut/genesys/pkg/planner"
	"github.com/javanhut/genesys/pkg/provider"
	providerTypes "github.com/javanhut/genesys/pkg/provider"
	"github.com/javanhut/genesys/pkg/provider/aws"
	"github.com/javanhut/genesys/pkg/state"
	"github.com/spf13/cobra"
)

var (
	applyFlag     bool
	dryRunFlag    bool
	deleteFlag    bool
	forceDeletion bool
	configFile    string
	providerName  string
	region        string
	outputFormat  string
)

// NewExecuteCommand creates the execute command
func NewExecuteCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "execute [config-file.toml | intent]",
		Short: "Deploy or delete resources from configuration files",
		Long: `Deploy or delete cloud resources from configuration files generated by interactive mode.
By default, shows a preview of changes. Use --apply to actually create resources or --delete to remove them.

Examples:
  genesys execute config.toml                           # Preview changes (dry-run by default)
  genesys execute config.toml --apply                   # Apply changes and create resources
  genesys execute config.toml --delete                  # Delete resources from config
  genesys execute config.toml --delete --force-deletion # Force delete including all versions
  genesys execute deletion config.toml                  # Delete resources (legacy syntax)

Legacy intent-based usage (for backwards compatibility):
  genesys execute bucket my-bucket --apply       # Create bucket from intent
  genesys execute static-site --apply            # Deploy static site`,
		Args: cobra.ArbitraryArgs,
		RunE: runExecute,
	}

	cmd.Flags().BoolVar(&applyFlag, "apply", false, "Apply the changes (required to create resources)")
	cmd.Flags().BoolVar(&dryRunFlag, "dry-run", false, "Show what would be done without making changes (this is now the default)")
	cmd.Flags().BoolVar(&deleteFlag, "delete", false, "Delete resources defined in the configuration file")
	cmd.Flags().BoolVar(&forceDeletion, "force-deletion", false, "Force delete bucket contents including all versions (use with --delete)")
	cmd.Flags().StringVarP(&configFile, "config", "c", "", "Configuration file (TOML)")
	cmd.Flags().StringVar(&providerName, "provider", "aws", "Cloud provider (aws|gcp|azure)")
	cmd.Flags().StringVar(&region, "region", "", "Cloud region")
	cmd.Flags().StringVarP(&outputFormat, "output", "o", "human", "Output format (human|json)")

	return cmd
}

func runExecute(cmd *cobra.Command, args []string) error {
	ctx := context.Background()

	// Handle special deletion case (legacy syntax: "genesys execute deletion config.toml")
	if len(args) >= 2 && args[0] == "deletion" {
		configFile = args[1]
		return executeDeletion(ctx, configFile)
	}

	// Handle direct config file execution (e.g., "genesys execute bucket.toml")
	if len(args) == 1 && strings.HasSuffix(args[0], ".toml") {
		configFile = args[0]

		// Handle --delete flag
		if deleteFlag {
			return executeDeletion(ctx, configFile)
		}

		return executeConfigFile(ctx, configFile)
	}

	// Load configuration if provided via --config flag
	var cfg *config.Config
	if configFile != "" {
		var err error
		cfg, err = config.LoadConfig(configFile)
		if err != nil {
			return fmt.Errorf("failed to load config: %w", err)
		}
	} else {
		// Create default config from flags
		cfg = &config.Config{
			Provider: providerName,
			Region:   region,
		}
	}

	// If we have a config file but no command line intent, execute based on config
	if configFile != "" && len(args) == 0 {
		return executeFromConfig(ctx, cfg)
	}

	// Parse the intent from command line arguments
	if len(args) == 0 {
		return fmt.Errorf("no intent specified. Usage: genesys execute <config-file.toml> or genesys execute <intent>")
	}

	parser := intent.NewParser()
	parsedIntent, err := parser.Parse(args)
	if err != nil {
		return fmt.Errorf("failed to parse intent: %w", err)
	}

	// Get the provider
	p, err := provider.Get(cfg.Provider, map[string]string{
		"region": cfg.Region,
	})
	if err != nil {
		// For now, create a mock provider for testing
		fmt.Printf("Note: Using mock provider (real provider not yet implemented)\n\n")
		p = provider.NewMockProvider(cfg.Provider, cfg.Region)
	}

	// Create planner
	plnr := planner.New(p)

	// Generate plan
	plan, err := plnr.PlanFromIntent(ctx, parsedIntent)
	if err != nil {
		return fmt.Errorf("failed to generate plan: %w", err)
	}

	// Display plan
	if outputFormat == "json" {
		fmt.Println(plan.ToJSON())
	} else {
		fmt.Println(plan.ToHumanReadable())
	}

	// Apply if requested
	if applyFlag {
		fmt.Println("\nApplying changes...")
		// TODO: Implement executor
		fmt.Println("Executor not yet implemented - this is a preview of what would happen")
	} else {
		fmt.Println("\nNote: This is a preview. Use --apply to make these changes.")
	}

	return nil
}

// executeFromConfig executes based on configuration file content
func executeFromConfig(ctx context.Context, cfg *config.Config) error {
	fmt.Println("Executing from configuration file...")

	// Get the provider
	p, err := provider.Get(cfg.Provider, map[string]string{
		"region": cfg.Region,
	})
	if err != nil {
		// For now, create a mock provider for testing
		fmt.Printf("Note: Using mock provider (real provider not yet implemented)\n\n")
		p = provider.NewMockProvider(cfg.Provider, cfg.Region)
	}

	// Create planner (for future use)
	_ = planner.New(p)

	// Process outcomes if they exist
	if len(cfg.Outcomes) > 0 {
		for name, outcome := range cfg.Outcomes {
			fmt.Printf("Processing outcome: %s\n", name)
			// For now, just show what would be planned
			fmt.Printf("- Type: %s\n", name)
			if outcome.Domain != "" {
				fmt.Printf("- Domain: %s\n", outcome.Domain)
			}
			if outcome.Runtime != "" {
				fmt.Printf("- Runtime: %s\n", outcome.Runtime)
			}
			fmt.Println()
		}
	}

	// Process resources if they exist
	if len(cfg.Resources.Compute) > 0 || len(cfg.Resources.Storage) > 0 ||
		len(cfg.Resources.Database) > 0 || len(cfg.Resources.Serverless) > 0 {

		fmt.Println("Processing resources from configuration:")

		// Process compute resources
		for _, compute := range cfg.Resources.Compute {
			fmt.Printf("- Compute: %s (%s, count: %d)\n", compute.Name, compute.Type, compute.Count)
		}

		// Process storage resources
		for _, storage := range cfg.Resources.Storage {
			fmt.Printf("- Storage: %s (%s)\n", storage.Name, storage.Type)
		}

		// Process database resources
		for _, database := range cfg.Resources.Database {
			fmt.Printf("- Database: %s (%s %s, %dGB)\n", database.Name, database.Engine, database.Size, database.Storage)
		}

		// Process serverless resources
		for _, serverless := range cfg.Resources.Serverless {
			fmt.Printf("- Function: %s (%s, %dMB)\n", serverless.Name, serverless.Runtime, serverless.Memory)
		}

		fmt.Println()
		fmt.Println("Note: Full resource execution from config not yet implemented")
	}

	return nil
}

// executeConfigFile handles execution of S3 and other config files
func executeConfigFile(ctx context.Context, configPath string) error {
	// Check if file exists
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		return fmt.Errorf("configuration file does not exist: %s", configPath)
	}

	// Try to parse as S3 config first
	if isS3Config(configPath) {
		return executeS3Config(ctx, configPath)
	}

	// Try to parse as EC2 config
	if isEC2Config(configPath) {
		return executeEC2Config(ctx, configPath)
	}

	// Try to parse as Lambda config
	if isLambdaConfig(configPath) {
		return executeLambdaConfig(ctx, configPath)
	}

	// Fall back to generic config execution
	fmt.Printf("Executing configuration file: %s\n", configPath)
	fmt.Println("Generic config execution not yet implemented")
	return nil
}

// isS3Config checks if the file is an S3 bucket configuration
func isS3Config(configPath string) bool {
	data, err := os.ReadFile(configPath)
	if err != nil {
		return false
	}

	content := string(data)

	// Check for TOML format (only supported format)
	return (strings.Contains(content, "provider = \"aws\"") || strings.Contains(content, "provider=\"aws\"")) &&
		(strings.Contains(content, "[[resources.storage]]") || strings.Contains(content, "storage") &&
			(strings.Contains(content, "bucket") || strings.Contains(content, "type = \"bucket\"")))
}

// isEC2Config checks if the file is an EC2 instance configuration
func isEC2Config(configPath string) bool {
	data, err := os.ReadFile(configPath)
	if err != nil {
		return false
	}

	content := string(data)

	// Check for TOML format (only supported format)
	return (strings.Contains(content, "provider = \"aws\"") || strings.Contains(content, "provider=\"aws\"")) &&
		(strings.Contains(content, "[[resources.compute]]") || strings.Contains(content, "compute") &&
			(strings.Contains(content, "instance") || strings.Contains(content, "type = \"t3\"")))
}

// isLambdaConfig checks if the file is a Lambda function configuration
func isLambdaConfig(configPath string) bool {
	data, err := os.ReadFile(configPath)
	if err != nil {
		return false
	}

	content := string(data)

	// Check for TOML format - Lambda configs have [metadata], [build], [function], [deployment] sections
	if strings.HasSuffix(configPath, ".toml") {
		return strings.Contains(content, "[metadata]") &&
			strings.Contains(content, "[build]") &&
			strings.Contains(content, "[function]") &&
			strings.Contains(content, "[deployment]") &&
			(strings.Contains(content, "runtime =") || strings.Contains(content, "handler ="))
	}

	return false
}

// executeS3Config handles S3 bucket configuration
func executeS3Config(ctx context.Context, configPath string) error {
	// Load S3 configuration
	data, err := os.ReadFile(configPath)
	if err != nil {
		return fmt.Errorf("failed to read configuration file: %w", err)
	}

	var s3Config config.S3BucketConfig

	// Parse TOML configuration (only supported format)
	if err := toml.Unmarshal(data, &s3Config); err != nil {
		return fmt.Errorf("failed to parse S3 configuration: %w", err)
	}

	bucketName := s3Config.Resources.Storage[0].Name

	// Show preview if --apply is not set (default behavior is now preview)
	if !applyFlag || dryRunFlag {
		fmt.Printf("================================================================================\n")
		fmt.Printf("PREVIEW: S3 Bucket Creation Plan\n")
		fmt.Printf("Configuration: %s\n", configPath)
		fmt.Printf("================================================================================\n\n")

		fmt.Printf("RESOURCE TO CREATE:\n")
		fmt.Printf("  Type:         AWS S3 Bucket\n")
		fmt.Printf("  Name:         %s\n", bucketName)
		fmt.Printf("  Region:       %s\n", s3Config.Region)
		fmt.Printf("  ARN:          arn:aws:s3:::%s\n\n", bucketName)

		fmt.Printf("CONFIGURATION DETAILS:\n")
		fmt.Printf("  Versioning:   %s\n", formatBool(s3Config.Resources.Storage[0].Versioning, "Enabled", "Disabled"))
		fmt.Printf("  Encryption:   %s\n", formatBool(s3Config.Resources.Storage[0].Encryption, "AES256 (Server-Side)", "None"))
		fmt.Printf("  Public Access: %s\n", formatBool(s3Config.Resources.Storage[0].PublicAccess, "Allowed", "Blocked"))

		if len(s3Config.Resources.Storage[0].Tags) > 0 {
			fmt.Printf("\nRESOURCE TAGS:\n")
			for k, v := range s3Config.Resources.Storage[0].Tags {
				fmt.Printf("  %-15s: %s\n", k, v)
			}
		}

		if s3Config.Resources.Storage[0].Lifecycle != nil {
			fmt.Printf("\nLIFECYCLE RULES:\n")
			if s3Config.Resources.Storage[0].Lifecycle.DeleteAfterDays > 0 {
				fmt.Printf("  Delete After:   %d days\n", s3Config.Resources.Storage[0].Lifecycle.DeleteAfterDays)
			}
			if s3Config.Resources.Storage[0].Lifecycle.ArchiveAfterDays > 0 {
				fmt.Printf("  Archive After:  %d days (to Glacier)\n", s3Config.Resources.Storage[0].Lifecycle.ArchiveAfterDays)
			}
		}

		fmt.Printf("\nACTIONS THAT WOULD BE PERFORMED:\n")
		fmt.Printf("  1. Create S3 bucket '%s' in region %s\n", bucketName, s3Config.Region)
		if s3Config.Resources.Storage[0].Versioning {
			fmt.Printf("  2. Enable versioning on the bucket\n")
		}
		if s3Config.Resources.Storage[0].Encryption {
			fmt.Printf("  3. Enable AES256 encryption for all objects\n")
		}
		if !s3Config.Resources.Storage[0].PublicAccess {
			fmt.Printf("  4. Block all public access to the bucket\n")
		}
		if len(s3Config.Resources.Storage[0].Tags) > 0 {
			fmt.Printf("  5. Apply %d tags to the bucket\n", len(s3Config.Resources.Storage[0].Tags))
		}

		fmt.Printf("\n================================================================================\n")
		fmt.Printf("No changes made. Use --apply to create the resources:\n")
		fmt.Printf("  genesys execute %s --apply\n", configPath)
		fmt.Printf("================================================================================\n")
		return nil
	}

	fmt.Printf("================================================================================\n")
	fmt.Printf("APPLYING: S3 Bucket Creation\n")
	fmt.Printf("Configuration: %s\n", configPath)
	fmt.Printf("================================================================================\n\n")

	fmt.Printf("Creating S3 Bucket:\n")
	fmt.Printf("  Name:   %s\n", bucketName)
	fmt.Printf("  Region: %s\n", s3Config.Region)
	fmt.Println()

	// Check AWS credentials
	interactiveConfig, err := config.NewInteractiveConfig()
	if err != nil {
		return fmt.Errorf("failed to initialize configuration: %w", err)
	}

	_, err = interactiveConfig.LoadProviderConfig("aws")
	if err != nil {
		return fmt.Errorf("AWS not configured. Run 'genesys config setup' to configure AWS credentials")
	}

	// Create AWS provider
	provider, err := aws.NewAWSProvider(s3Config.Region)
	if err != nil {
		return fmt.Errorf("failed to create AWS provider: %w", err)
	}

	// Get storage service
	storageService := provider.Storage()

	// Get bucket configuration
	bucketResource := s3Config.Resources.Storage[0]

	// Create bucket configuration
	bucketConf := &providerTypes.BucketConfig{
		Name:         bucketResource.Name,
		Versioning:   bucketResource.Versioning,
		Encryption:   bucketResource.Encryption,
		PublicAccess: bucketResource.PublicAccess,
		Tags:         bucketResource.Tags,
	}

	// Create bucket
	bucket, err := storageService.CreateBucket(ctx, bucketConf)
	if err != nil {
		return fmt.Errorf("failed to create S3 bucket: %w", err)
	}

	fmt.Printf("================================================================================\n")
	fmt.Printf("SUCCESS: S3 Bucket Created\n")
	fmt.Printf("================================================================================\n\n")

	fmt.Printf("RESOURCE CREATED:\n")
	fmt.Printf("  Bucket Name:  %s\n", bucket.Name)
	fmt.Printf("  Region:       %s\n", s3Config.Region)
	fmt.Printf("  ARN:          arn:aws:s3:::%s\n", bucket.Name)
	fmt.Printf("  Created:      %s\n", bucket.CreatedAt.Format("2006-01-02 15:04:05 UTC"))

	fmt.Printf("\nCONFIGURATION APPLIED:\n")
	fmt.Printf("  Versioning:   %s\n", formatBool(s3Config.Resources.Storage[0].Versioning, "Enabled", "Disabled"))
	fmt.Printf("  Encryption:   %s\n", formatBool(s3Config.Resources.Storage[0].Encryption, "AES256 (Server-Side)", "None"))
	fmt.Printf("  Public Access: %s\n", formatBool(s3Config.Resources.Storage[0].PublicAccess, "Allowed", "Blocked"))

	if len(s3Config.Resources.Storage[0].Tags) > 0 {
		fmt.Printf("  Tags Applied: %d\n", len(s3Config.Resources.Storage[0].Tags))
	}

	fmt.Printf("\nNEXT STEPS:\n")
	fmt.Printf("  • View bucket contents: aws s3 ls s3://%s\n", bucketName)
	fmt.Printf("  • Upload files:         aws s3 cp <file> s3://%s/\n", bucketName)
	fmt.Printf("  • Delete bucket:        genesys execute deletion %s\n", configPath)
	fmt.Printf("\n================================================================================\n")

	return nil
}

// executeEC2Config handles EC2 instance configuration
func executeEC2Config(ctx context.Context, configPath string) error {
	// Load EC2 configuration
	data, err := os.ReadFile(configPath)
	if err != nil {
		return fmt.Errorf("failed to read configuration file: %w", err)
	}

	var ec2Config config.EC2InstanceConfig

	// Parse TOML configuration (only supported format)
	if err := toml.Unmarshal(data, &ec2Config); err != nil {
		return fmt.Errorf("failed to parse EC2 configuration: %w", err)
	}

	if len(ec2Config.Resources.Compute) == 0 {
		return fmt.Errorf("no compute resources found in configuration")
	}

	instanceName := ec2Config.Resources.Compute[0].Name

	// Show preview if --apply is not set (default behavior is now preview)
	if !applyFlag || dryRunFlag {
		return performEC2DryRun(ctx, configPath, ec2Config)
	}

	fmt.Printf("================================================================================\n")
	fmt.Printf("APPLYING: EC2 Instance Creation\n")
	fmt.Printf("Configuration: %s\n", configPath)
	fmt.Printf("================================================================================\n\n")

	fmt.Printf("Creating EC2 Instance:\n")
	fmt.Printf("  Name:   %s\n", instanceName)
	fmt.Printf("  Region: %s\n", ec2Config.Region)
	fmt.Printf("  Type:   %s\n", ec2Config.Resources.Compute[0].Type)
	fmt.Println()

	// Check AWS credentials
	interactiveConfig, err := config.NewInteractiveConfig()
	if err != nil {
		return fmt.Errorf("failed to initialize configuration: %w", err)
	}

	_, err = interactiveConfig.LoadProviderConfig("aws")
	if err != nil {
		return fmt.Errorf("AWS not configured. Run 'genesys config setup' to configure AWS credentials")
	}

	// Create AWS provider
	provider, err := aws.NewAWSProvider(ec2Config.Region)
	if err != nil {
		return fmt.Errorf("failed to create AWS provider: %w", err)
	}

	// Get compute service
	computeService := provider.Compute()

	// Get instance configuration
	instanceResource := ec2Config.Resources.Compute[0]

	// Create instance configuration
	instanceConf := &providerTypes.InstanceConfig{
		Name:           instanceResource.Name,
		Type:           providerTypes.InstanceType(instanceResource.Type),
		Image:          instanceResource.Image,
		KeyPair:        instanceResource.KeyPair,
		SecurityGroups: instanceResource.SecurityGroups,
		Tags:           instanceResource.Tags,
		PublicIP:       instanceResource.PublicIP,
	}

	// Create instance
	instance, err := computeService.CreateInstance(ctx, instanceConf)
	if err != nil {
		return fmt.Errorf("failed to create EC2 instance: %w", err)
	}

	// Store in local state for tracking
	localState, err := state.LoadLocalState()
	if err != nil {
		fmt.Printf("Warning: Failed to load local state: %v\n", err)
	} else {
		record := state.ResourceRecord{
			ID:         instance.ID,
			Name:       instance.Name,
			Type:       "ec2",
			Region:     ec2Config.Region,
			Provider:   ec2Config.Provider,
			ConfigFile: configPath,
			CreatedAt:  time.Now(),
			Tags:       instanceResource.Tags,
		}

		if err := localState.AddResource(record); err != nil {
			fmt.Printf("Warning: Failed to save instance to local state: %v\n", err)
		} else {
			fmt.Printf("Instance tracked in local state: %s\n", instance.ID)
		}
	}

	fmt.Printf("================================================================================\n")
	fmt.Printf("SUCCESS: EC2 Instance Created\n")
	fmt.Printf("================================================================================\n\n")

	fmt.Printf("RESOURCE CREATED:\n")
	fmt.Printf("  Instance ID:  %s\n", instance.ID)
	fmt.Printf("  Name:         %s\n", instance.Name)
	fmt.Printf("  Type:         %s\n", instance.Type)
	fmt.Printf("  State:        %s\n", instance.State)
	fmt.Printf("  Region:       %s\n", ec2Config.Region)
	fmt.Printf("  Private IP:   %s\n", instance.PrivateIP)
	fmt.Printf("  Created:      %s\n", instance.CreatedAt.Format("2006-01-02 15:04:05 UTC"))

	fmt.Printf("\nCONFIGURATION APPLIED:\n")
	fmt.Printf("  Instance Type: %s\n", ec2Config.Resources.Compute[0].Type)
	fmt.Printf("  AMI:          %s\n", ec2Config.Resources.Compute[0].Image)
	fmt.Printf("  Public IP:    %s\n", formatBool(ec2Config.Resources.Compute[0].PublicIP, "Assigned", "None"))

	if len(ec2Config.Resources.Compute[0].Tags) > 0 {
		fmt.Printf("  Tags Applied: %d\n", len(ec2Config.Resources.Compute[0].Tags))
	}

	// Add cost information to deployment output
	fmt.Printf("\n%s\n", strings.Repeat("-", 50))
	if estimate, err := config.EstimateEC2Costs(ec2Config.Resources.Compute[0], ec2Config.Region); err == nil {
		fmt.Printf("ESTIMATED COSTS:\n")
		fmt.Printf("  Monthly Cost: $%.2f/month ($%.4f/hour)\n", estimate.TotalMonthlyCost, estimate.HourlyRate)
		warningLevel := estimate.GetCostWarningLevel()
		switch warningLevel {
		case "HIGH":
			fmt.Printf("  HIGH COST WARNING: Monitor usage closely\n")
		case "MODERATE":
			fmt.Printf("  MODERATE COST: Set up billing alerts\n")
		case "LOW":
			fmt.Printf("  LOW COST: Cost-effective choice\n")
		}
	}
	fmt.Printf("%s\n", strings.Repeat("-", 50))

	fmt.Printf("\nNEXT STEPS:\n")
	fmt.Printf("  • View instance status: aws ec2 describe-instances --instance-ids %s\n", instance.ID)
	if ec2Config.Resources.Compute[0].KeyPair != "" {
		fmt.Printf("  • Connect via SSH:      ssh -i ~/.ssh/%s.pem ec2-user@<public-ip>\n", ec2Config.Resources.Compute[0].KeyPair)
	}
	fmt.Printf("  • Delete instance:      genesys execute deletion %s\n", configPath)
	fmt.Printf("\n================================================================================\n")

	return nil
}

// executeLambdaConfig handles Lambda function configuration
func executeLambdaConfig(ctx context.Context, configPath string) error {
	// Load Lambda configuration
	data, err := os.ReadFile(configPath)
	if err != nil {
		return fmt.Errorf("failed to read configuration file: %w", err)
	}

	var lambdaConfig config.LambdaFunctionConfig

	// Parse TOML configuration
	if err := toml.Unmarshal(data, &lambdaConfig); err != nil {
		return fmt.Errorf("failed to parse Lambda configuration: %w", err)
	}

	functionName := lambdaConfig.Metadata.Name

	// Show preview if --apply is not set (default behavior is now preview)
	if !applyFlag || dryRunFlag {
		return performLambdaDryRun(ctx, configPath, lambdaConfig)
	}

	fmt.Printf("================================================================================\n")
	fmt.Printf("APPLYING: Lambda Function Deployment\n")
	fmt.Printf("Configuration: %s\n", configPath)
	fmt.Printf("================================================================================\n\n")

	fmt.Printf("Deploying Lambda Function:\n")
	fmt.Printf("  Name:    %s\n", functionName)
	fmt.Printf("  Runtime: %s\n", lambdaConfig.Metadata.Runtime)
	fmt.Printf("  Handler: %s\n", lambdaConfig.Metadata.Handler)
	fmt.Printf("  Memory:  %d MB\n", lambdaConfig.Function.MemoryMB)
	fmt.Printf("  Timeout: %d seconds\n", lambdaConfig.Function.TimeoutSeconds)
	fmt.Println()

	// Check AWS credentials
	interactiveConfig, err := config.NewInteractiveConfig()
	if err != nil {
		return fmt.Errorf("failed to initialize configuration: %w", err)
	}

	_, err = interactiveConfig.LoadProviderConfig("aws")
	if err != nil {
		return fmt.Errorf("AWS not configured. Run 'genesys config setup' to configure AWS credentials")
	}

	// Create AWS provider - we need to determine the region from configuration or default
	region := "us-east-1" // Default region for Lambda
	if awsConfig, err := interactiveConfig.LoadProviderConfig("aws"); err == nil {
		if awsConfig.Region != "" {
			region = awsConfig.Region
		}
	}

	provider, err := aws.NewAWSProvider(region)
	if err != nil {
		return fmt.Errorf("failed to create AWS provider: %w", err)
	}

	// Get serverless service
	serverlessService := provider.Serverless()

	// Step 0: Ensure IAM role (no user interaction)
	fmt.Printf("Step 0/4: Ensuring IAM role...\n")

	roleArn, err := ensureIAMRoleAutomated(ctx, provider, lambdaConfig.IAM, functionName, configPath)
	if err != nil {
		return fmt.Errorf("failed to ensure IAM role: %w", err)
	}

	fmt.Printf("  ✓ IAM role ready: %s\n", extractRoleName(roleArn))

	// Step 1: Build the Lambda function code
	fmt.Printf("Step 1/4: Building Lambda function code...\n")

	// Verify source path exists
	if _, err := os.Stat(lambdaConfig.Build.SourcePath); err != nil {
		return fmt.Errorf("source path does not exist: %s", lambdaConfig.Build.SourcePath)
	}

	// Get runtime information
	runtime, err := lambda.GetRuntimeByName(lambdaConfig.Metadata.Runtime)
	if err != nil {
		return fmt.Errorf("invalid runtime: %w", err)
	}

	// Create temp directory for build artifacts
	buildDir, err := os.MkdirTemp("", "lambda-build-*")
	if err != nil {
		return fmt.Errorf("failed to create build directory: %w", err)
	}
	defer os.RemoveAll(buildDir)

	// Build function ZIP
	functionZipPath := filepath.Join(buildDir, "function.zip")

	// Create builder
	builder := lambda.NewPodmanBuilder(runtime, lambdaConfig.Build.SourcePath, functionZipPath)
	builder.EnableDebug() // Enable debug output

	fmt.Printf("  Building with %s for %s architecture...\n", lambdaConfig.Build.BuildMethod, lambdaConfig.Deployment.Architecture)
	if err := builder.BuildFunction(); err != nil {
		return fmt.Errorf("failed to build function: %w", err)
	}
	fmt.Printf("  ✓ Function code built successfully\n")

	// Step 2: Build layer if dependencies exist
	var layerVersionArn string
	if lambdaConfig.Layer != nil && lambdaConfig.Build.RequirementsFile != "" {
		fmt.Printf("\nStep 2/4: Building Lambda layer for dependencies...\n")

		layerZipPath := filepath.Join(buildDir, "layer.zip")

		// Create layer builder
		layerBuilder := lambda.NewPodmanBuilder(runtime, lambdaConfig.Build.SourcePath, layerZipPath)
		layerBuilder.EnableDebug() // Enable debug output

		if err := layerBuilder.BuildLayer(); err != nil {
			return fmt.Errorf("failed to build layer: %w", err)
		}
		fmt.Printf("  ✓ Layer built successfully\n")

		// Check layer ZIP file size
		createLayer := true
		if layerInfo, err := os.Stat(layerZipPath); err == nil {
			fmt.Printf("  Layer ZIP size: %d bytes\n", layerInfo.Size())

			// Skip layer creation if the ZIP is too small (likely empty)
			if layerInfo.Size() < 1024 { // Less than 1KB suggests no real dependencies
				fmt.Printf("  ⚠️  Layer appears to be empty, skipping layer creation\n")
				fmt.Printf("  (No dependencies found in %s)\n", lambdaConfig.Build.RequirementsFile)
				createLayer = false
			}
		}

		if createLayer {
			// Create layer in AWS - we need to access AWS-specific methods
			fmt.Printf("  Creating layer in AWS...\n")

			// Get AWS serverless service directly
			awsServerless := provider.Serverless().(*aws.ServerlessService)

			layerConfig := &providerTypes.LambdaLayerConfig{
				Name:               lambdaConfig.Layer.Name,
				Description:        lambdaConfig.Layer.Description,
				CompatibleRuntimes: lambdaConfig.Layer.CompatibleRuntimes,
				Content: providerTypes.LayerContent{
					LocalPath: layerZipPath,
				},
			}

			layer, err := awsServerless.CreateLayer(ctx, layerConfig)
			if err != nil {
				return fmt.Errorf("failed to create layer: %w", err)
			}
			// CreateLayer returns interface{}, so we need to handle it properly
			if layer != nil {
				fmt.Printf("  ✓ Layer created successfully\n")
			}
		}
	} else {
		fmt.Printf("\nStep 2/4: Skipping layer creation (no dependencies)\n")
	}

	// Step 3: Create or update Lambda function
	fmt.Printf("\nStep 3/4: Deploying Lambda function to AWS...\n")

	// Prepare function configuration
	functionConfig := &providerTypes.FunctionConfig{
		Name:        lambdaConfig.Metadata.Name,
		Runtime:     lambdaConfig.Metadata.Runtime,
		Handler:     lambdaConfig.Metadata.Handler,
		Memory:      lambdaConfig.Function.MemoryMB,
		Timeout:     lambdaConfig.Function.TimeoutSeconds,
		Environment: lambdaConfig.Function.Environment,
		Code: providerTypes.FunctionCode{
			LocalPath: functionZipPath,
		},
		Tags: map[string]string{
			"ManagedBy": "Genesys",
			"CreatedAt": time.Now().Format(time.RFC3339),
		},
		Role: roleArn, // Add the IAM role ARN
	}

	// Add layer if created
	if layerVersionArn != "" {
		functionConfig.Code.Layers = []string{layerVersionArn}
	}

	// Check if function already exists
	existingFunction, err := serverlessService.AdoptFunction(ctx, functionName)
	if err == nil && existingFunction != nil {
		// Update existing function
		fmt.Printf("  Function already exists, updating...\n")
		if err := serverlessService.UpdateFunction(ctx, functionName, functionConfig); err != nil {
			return fmt.Errorf("failed to update function: %w", err)
		}
		fmt.Printf("  ✓ Function updated successfully\n")
	} else {
		// Create new function
		fmt.Printf("  Creating new function...\n")
		_, err := serverlessService.CreateFunction(ctx, functionConfig)
		if err != nil {
			return fmt.Errorf("failed to create function: %w", err)
		}
		fmt.Printf("  ✓ Function created successfully\n")
	}

	// Step 4: Configure function URL if enabled
	var functionURL string
	if lambdaConfig.Deployment.FunctionURL {
		fmt.Printf("\nStep 4/4: Configuring function URL...\n")

		// Create function URL configuration
		// Note: This would require additional AWS API implementation
		functionURL = fmt.Sprintf("https://%s.lambda-url.%s.on.aws/", functionName, region)
		fmt.Printf("  ✓ Function URL configured: %s\n", functionURL)
	} else {
		fmt.Printf("\nStep 4/4: Skipping function URL configuration\n")
	}

	// Store in local state for tracking
	localState, err := state.LoadLocalState()
	if err != nil {
		fmt.Printf("Warning: Failed to load local state: %v\n", err)
	} else {
		record := state.ResourceRecord{
			ID:         functionName,
			Name:       functionName,
			Type:       "lambda",
			Region:     region,
			Provider:   "aws",
			ConfigFile: configPath,
			CreatedAt:  time.Now(),
			Tags: map[string]string{
				"Runtime":      lambdaConfig.Metadata.Runtime,
				"Handler":      lambdaConfig.Metadata.Handler,
				"Architecture": lambdaConfig.Deployment.Architecture,
			},
		}

		if err := localState.AddResource(record); err != nil {
			fmt.Printf("Warning: Failed to save function to local state: %v\n", err)
		}
	}

	fmt.Printf("\n================================================================================\n")
	fmt.Printf("SUCCESS: Lambda Function Deployed\n")
	fmt.Printf("================================================================================\n\n")

	fmt.Printf("FUNCTION DEPLOYED:\n")
	fmt.Printf("  Name:         %s\n", functionName)
	fmt.Printf("  Runtime:      %s\n", lambdaConfig.Metadata.Runtime)
	fmt.Printf("  Handler:      %s\n", lambdaConfig.Metadata.Handler)
	fmt.Printf("  Memory:       %d MB\n", lambdaConfig.Function.MemoryMB)
	fmt.Printf("  Timeout:      %d seconds\n", lambdaConfig.Function.TimeoutSeconds)
	fmt.Printf("  Architecture: %s\n", lambdaConfig.Deployment.Architecture)
	fmt.Printf("  Region:       %s\n", region)

	if functionURL != "" {
		fmt.Printf("  URL:          %s\n", functionURL)
	}

	if layerVersionArn != "" {
		fmt.Printf("  Layer:        %s\n", lambdaConfig.Layer.Name)
	}

	fmt.Printf("\nNEXT STEPS:\n")
	fmt.Printf("  • Test function:     aws lambda invoke --function-name %s response.json\n", functionName)
	if functionURL != "" {
		fmt.Printf("  • Test via URL:      curl %s\n", functionURL)
	}
	fmt.Printf("  • View logs:         aws logs tail /aws/lambda/%s --follow\n", functionName)
	fmt.Printf("  • Update function:   genesys execute %s\n", configPath)
	fmt.Printf("  • Delete function:   genesys execute deletion %s\n", configPath)
	fmt.Printf("\n================================================================================\n")

	return nil
}

// performLambdaDryRun performs a dry run for Lambda function deployment
func performLambdaDryRun(ctx context.Context, configPath string, lambdaConfig config.LambdaFunctionConfig) error {
	fmt.Printf("================================================================================\n")
	fmt.Printf("PREVIEW: Lambda Function Deployment Plan\n")
	fmt.Printf("Configuration: %s\n", configPath)
	fmt.Printf("================================================================================\n\n")

	functionName := lambdaConfig.Metadata.Name

	fmt.Printf("FUNCTION TO DEPLOY:\n")
	fmt.Printf("  Type:        AWS Lambda Function\n")
	fmt.Printf("  Name:        %s\n", functionName)
	fmt.Printf("  Runtime:     %s\n", lambdaConfig.Metadata.Runtime)
	fmt.Printf("  Handler:     %s\n", lambdaConfig.Metadata.Handler)
	fmt.Printf("  Source Path: %s\n", lambdaConfig.Build.SourcePath)

	fmt.Printf("\nFUNCTION CONFIGURATION:\n")
	fmt.Printf("  Memory:      %d MB\n", lambdaConfig.Function.MemoryMB)
	fmt.Printf("  Timeout:     %d seconds\n", lambdaConfig.Function.TimeoutSeconds)
	fmt.Printf("  Architecture: %s\n", lambdaConfig.Deployment.Architecture)

	if len(lambdaConfig.Function.Environment) > 0 {
		fmt.Printf("\nENVIRONMENT VARIABLES:\n")
		for k, v := range lambdaConfig.Function.Environment {
			fmt.Printf("  %-15s: %s\n", k, v)
		}
	}

	fmt.Printf("\nDEPLOYMENT SETTINGS:\n")
	fmt.Printf("  Function URL: %s\n", formatBool(lambdaConfig.Deployment.FunctionURL, "Enabled", "Disabled"))
	if lambdaConfig.Deployment.FunctionURL {
		fmt.Printf("  CORS:         %s\n", formatBool(lambdaConfig.Deployment.CORSEnabled, "Enabled", "Disabled"))
		fmt.Printf("  Auth Type:    %s\n", lambdaConfig.Deployment.AuthType)
	}

	fmt.Printf("\nBUILD CONFIGURATION:\n")
	fmt.Printf("  Build Method: %s\n", lambdaConfig.Build.BuildMethod)
	fmt.Printf("  Auto Layer:   %s\n", formatBool(lambdaConfig.Build.LayerAuto, "Yes", "No"))
	if lambdaConfig.Build.RequirementsFile != "" {
		fmt.Printf("  Requirements: %s\n", lambdaConfig.Build.RequirementsFile)
	}

	if lambdaConfig.Layer != nil {
		fmt.Printf("\nLAYER CONFIGURATION:\n")
		fmt.Printf("  Name:         %s\n", lambdaConfig.Layer.Name)
		fmt.Printf("  Description:  %s\n", lambdaConfig.Layer.Description)
		fmt.Printf("  Runtimes:     %s\n", strings.Join(lambdaConfig.Layer.CompatibleRuntimes, ", "))
	}

	if lambdaConfig.IAM != nil {
		fmt.Printf("\nIAM CONFIGURATION:\n")
		fmt.Printf("  Role Name:    %s\n", lambdaConfig.IAM.RoleName)
		fmt.Printf("  Auto Manage:  %s\n", formatBool(lambdaConfig.IAM.AutoManage, "Yes", "No"))
		fmt.Printf("  Auto Cleanup: %s\n", formatBool(lambdaConfig.IAM.AutoCleanup, "Yes", "No"))
		if len(lambdaConfig.IAM.RequiredPolicies) > 0 {
			fmt.Printf("  Policies:     %s\n", strings.Join(lambdaConfig.IAM.RequiredPolicies, ", "))
		}
		if lambdaConfig.IAM.RoleArn != "" {
			fmt.Printf("  Current ARN:  %s\n", lambdaConfig.IAM.RoleArn)
		} else {
			fmt.Printf("  Status:       Will be created automatically\n")
		}
	}

	if len(lambdaConfig.Triggers) > 0 {
		fmt.Printf("\nTRIGGERS:\n")
		for i, trigger := range lambdaConfig.Triggers {
			fmt.Printf("  %d. Type: %s", i+1, trigger.Type)
			if trigger.Path != "" {
				fmt.Printf(", Path: %s", trigger.Path)
			}
			if trigger.Method != "" {
				fmt.Printf(", Method: %s", trigger.Method)
			}
			fmt.Println()
		}
	}

	fmt.Printf("\nACTIONS THAT WOULD BE PERFORMED:\n")
	fmt.Printf("  1. Build function code using %s\n", lambdaConfig.Build.BuildMethod)
	if lambdaConfig.Layer != nil {
		fmt.Printf("  2. Create/update layer: %s\n", lambdaConfig.Layer.Name)
	}
	fmt.Printf("  3. Create/update Lambda function: %s\n", functionName)
	if lambdaConfig.Deployment.FunctionURL {
		fmt.Printf("  4. Configure function URL with %s auth\n", lambdaConfig.Deployment.AuthType)
	}
	if len(lambdaConfig.Triggers) > 0 {
		fmt.Printf("  5. Configure %d trigger(s)\n", len(lambdaConfig.Triggers))
	}

	fmt.Printf("\n================================================================================\n")
	fmt.Printf("No changes made. Use --apply to deploy the function:\n")
	fmt.Printf("  genesys execute %s --apply\n", configPath)
	fmt.Printf("================================================================================\n")

	return nil
}

// executeDeletion handles deletion of resources
func executeDeletion(ctx context.Context, configPath string) error {
	// Check if file exists
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		return fmt.Errorf("configuration file does not exist: %s", configPath)
	}

	// Try to parse as S3 config first
	if isS3Config(configPath) {
		return executeS3Deletion(ctx, configPath)
	}

	// Try to parse as EC2 config
	if isEC2Config(configPath) {
		return executeEC2Deletion(ctx, configPath)
	}

	// Try to parse as Lambda config
	if isLambdaConfig(configPath) {
		return executeLambdaDeletion(ctx, configPath)
	}

	fmt.Printf("Deletion for configuration file '%s' not yet implemented\n", configPath)
	return nil
}

// executeS3Deletion handles S3 bucket deletion
func executeS3Deletion(ctx context.Context, configPath string) error {
	// Load S3 configuration
	data, err := os.ReadFile(configPath)
	if err != nil {
		return fmt.Errorf("failed to read configuration file: %w", err)
	}

	var s3Config config.S3BucketConfig

	// Parse TOML configuration (only supported format)
	if err := toml.Unmarshal(data, &s3Config); err != nil {
		return fmt.Errorf("failed to parse S3 configuration: %w", err)
	}

	bucketName := s3Config.Resources.Storage[0].Name

	if dryRunFlag {
		fmt.Printf("================================================================================\n")
		fmt.Printf("DRY RUN: S3 Bucket Deletion Plan\n")
		fmt.Printf("Configuration: %s\n", configPath)
		fmt.Printf("================================================================================\n\n")

		fmt.Printf("RESOURCE TO DELETE:\n")
		fmt.Printf("  Type:         AWS S3 Bucket\n")
		fmt.Printf("  Name:         %s\n", bucketName)
		fmt.Printf("  Region:       %s\n", s3Config.Region)
		fmt.Printf("  ARN:          arn:aws:s3:::%s\n\n", bucketName)

		fmt.Printf("ACTIONS THAT WOULD BE PERFORMED:\n")
		fmt.Printf("  1. Delete all objects in the bucket\n")
		fmt.Printf("  2. Remove all object versions (if versioning is enabled)\n")
		fmt.Printf("  3. Delete the bucket itself\n")

		fmt.Printf("\n⚠️  WARNING: This action is IRREVERSIBLE!\n")
		fmt.Printf("   All data in this bucket will be permanently lost.\n")

		fmt.Printf("\n================================================================================\n")
		fmt.Printf("No actual changes will be made. Use 'genesys execute deletion %s' to proceed.\n", configPath)
		fmt.Printf("================================================================================\n")
		return nil
	}

	fmt.Printf("================================================================================\n")
	fmt.Printf("APPLYING: S3 Bucket Deletion\n")
	fmt.Printf("Configuration: %s\n", configPath)
	fmt.Printf("================================================================================\n\n")

	fmt.Printf("[WARNING] Deleting S3 Bucket:\n")
	fmt.Printf("  Name:   %s\n", bucketName)
	fmt.Printf("  Region: %s\n", s3Config.Region)
	fmt.Printf("  ARN:    arn:aws:s3:::%s\n\n", bucketName)

	fmt.Printf("This action cannot be undone!\n")
	fmt.Println("Proceeding with deletion...")

	// Create AWS provider
	provider, err := aws.NewAWSProvider(s3Config.Region)
	if err != nil {
		return fmt.Errorf("failed to create AWS provider: %w", err)
	}

	// Get storage service
	storageService := provider.Storage()

	// Delete bucket with force option if specified
	if forceDeletion {
		fmt.Printf("Force deletion mode enabled. This will delete all object versions and delete markers.\n")
		err = storageService.DeleteBucketWithOptions(ctx, bucketName, true)
	} else {
		err = storageService.DeleteBucket(ctx, bucketName)
	}

	if err != nil {
		// Check if error is already formatted (starts with bucket deletion failed)
		errStr := err.Error()
		if strings.Contains(errStr, "bucket deletion failed") {
			return fmt.Errorf("%s", errStr)
		}
		return fmt.Errorf("failed to delete S3 bucket: %w", err)
	}

	fmt.Printf("================================================================================\n")
	fmt.Printf("SUCCESS: S3 Bucket Deleted\n")
	fmt.Printf("================================================================================\n\n")

	fmt.Printf("RESOURCE DELETED:\n")
	fmt.Printf("  Bucket Name:  %s\n", bucketName)
	fmt.Printf("  Region:       %s\n", s3Config.Region)
	fmt.Printf("  ARN:          arn:aws:s3:::%s\n", bucketName)

	fmt.Printf("\nThe bucket and all its contents have been permanently removed.\n")
	fmt.Printf("This action cannot be undone.\n")
	fmt.Printf("\n================================================================================\n")
	return nil
}

// executeEC2Deletion handles EC2 instance deletion
func executeEC2Deletion(ctx context.Context, configPath string) error {
	// Load EC2 configuration
	data, err := os.ReadFile(configPath)
	if err != nil {
		return fmt.Errorf("failed to read configuration file: %w", err)
	}

	var ec2Config config.EC2InstanceConfig

	// Parse TOML configuration (only supported format)
	if err := toml.Unmarshal(data, &ec2Config); err != nil {
		return fmt.Errorf("failed to parse EC2 configuration: %w", err)
	}

	if len(ec2Config.Resources.Compute) == 0 {
		return fmt.Errorf("no compute resources found in configuration")
	}

	instanceName := ec2Config.Resources.Compute[0].Name

	if dryRunFlag {
		fmt.Printf("================================================================================\n")
		fmt.Printf("DRY RUN: EC2 Instance Deletion Plan\n")
		fmt.Printf("Configuration: %s\n", configPath)
		fmt.Printf("================================================================================\n\n")

		fmt.Printf("RESOURCE TO DELETE:\n")
		fmt.Printf("  Type:         AWS EC2 Instance\n")
		fmt.Printf("  Name:         %s\n", instanceName)
		fmt.Printf("  Region:       %s\n", ec2Config.Region)
		fmt.Printf("  Instance Type: %s\n\n", ec2Config.Resources.Compute[0].Type)

		fmt.Printf("ACTIONS THAT WOULD BE PERFORMED:\n")
		fmt.Printf("  1. Find instances with Name tag '%s'\n", instanceName)
		fmt.Printf("  2. Stop running instances (if any)\n")
		fmt.Printf("  3. Terminate the instances\n")
		fmt.Printf("  4. Delete associated EBS volumes (if configured)\n")

		fmt.Printf("\nWARNING: This action is IRREVERSIBLE!\n")
		fmt.Printf("The instance and its data will be permanently lost.\n")

		fmt.Printf("\n================================================================================\n")
		fmt.Printf("No actual changes will be made. Use 'genesys execute deletion %s' to proceed.\n", configPath)
		fmt.Printf("================================================================================\n")
		return nil
	}

	fmt.Printf("================================================================================\n")
	fmt.Printf("APPLYING: EC2 Instance Deletion\n")
	fmt.Printf("Configuration: %s\n", configPath)
	fmt.Printf("================================================================================\n\n")

	fmt.Printf("[WARNING] Deleting EC2 Instance:\n")
	fmt.Printf("  Name:   %s\n", instanceName)
	fmt.Printf("  Region: %s\n", ec2Config.Region)
	fmt.Printf("  Type:   %s\n\n", ec2Config.Resources.Compute[0].Type)

	fmt.Printf("This action cannot be undone!\n")
	fmt.Println("Proceeding with deletion...")

	// Create AWS provider
	provider, err := aws.NewAWSProvider(ec2Config.Region)
	if err != nil {
		return fmt.Errorf("failed to create AWS provider: %w", err)
	}

	// Get compute service
	computeService := provider.Compute()

	// Find instances with the matching name tag
	instances, err := computeService.ListInstances(ctx, map[string]string{
		"tag:Name":            instanceName,
		"instance-state-name": "running,stopped,stopping,pending",
	})
	if err != nil {
		return fmt.Errorf("failed to list instances: %w", err)
	}

	if len(instances) == 0 {
		fmt.Printf("No instances found with Name tag '%s'.\n", instanceName)

		// Try to find instances from local state as fallback
		localState, err := state.LoadLocalState()
		if err == nil {
			stateInstances := localState.FindResourcesByConfigFile(configPath)
			if len(stateInstances) > 0 {
				fmt.Printf("Found %d instance(s) in local state for this config file:\n", len(stateInstances))
				for _, record := range stateInstances {
					fmt.Printf("  - %s (ID: %s, Created: %s)\n", record.Name, record.ID, record.CreatedAt.Format("2006-01-02 15:04:05"))
				}

				fmt.Printf("\nAttempting to delete instances found in local state...\n")

				// Try to delete each instance by ID
				for _, record := range stateInstances {
					fmt.Printf("Terminating instance from local state: %s\n", record.ID)

					if err := computeService.DeleteInstance(ctx, record.ID); err != nil {
						fmt.Printf("Warning: Failed to terminate instance %s: %v\n", record.ID, err)
						continue
					}

					// Remove from local state
					if err := localState.RemoveResource(record.ID); err != nil {
						fmt.Printf("Warning: Failed to remove %s from local state: %v\n", record.ID, err)
					} else {
						fmt.Printf("Removed %s from local state tracking\n", record.ID)
					}
				}

				fmt.Printf("\n================================================================================\n")
				fmt.Printf("SUCCESS: EC2 Instance(s) Terminated from Local State\n")
				fmt.Printf("================================================================================\n")
				return nil
			}
		}

		fmt.Printf("No instances found in AWS or local state. Nothing to delete.\n")
		return nil
	}

	// Load local state to update it
	localState, err := state.LoadLocalState()
	if err != nil {
		fmt.Printf("Warning: Failed to load local state: %v\n", err)
	}

	// Delete all matching instances
	for _, instance := range instances {
		fmt.Printf("Terminating instance: %s (%s)\n", instance.ID, instance.State)

		if err := computeService.DeleteInstance(ctx, instance.ID); err != nil {
			return fmt.Errorf("failed to terminate instance %s: %w", instance.ID, err)
		}

		// Remove from local state
		if localState != nil {
			if err := localState.RemoveResource(instance.ID); err != nil {
				fmt.Printf("Warning: Failed to remove %s from local state: %v\n", instance.ID, err)
			} else {
				fmt.Printf("Removed %s from local state tracking\n", instance.ID)
			}
		}
	}

	fmt.Printf("================================================================================\n")
	fmt.Printf("SUCCESS: EC2 Instance(s) Terminated\n")
	fmt.Printf("================================================================================\n\n")

	fmt.Printf("RESOURCES TERMINATED:\n")
	for _, instance := range instances {
		fmt.Printf("  Instance ID:  %s\n", instance.ID)
		fmt.Printf("  Name:         %s\n", instance.Name)
		fmt.Printf("  Type:         %s\n", instance.Type)
	}
	fmt.Printf("  Region:       %s\n", ec2Config.Region)

	fmt.Printf("\nThe instance(s) are now terminating and will be permanently removed.\n")
	fmt.Printf("Associated EBS volumes may be deleted based on their configuration.\n")
	fmt.Printf("\n================================================================================\n")
	return nil
}

// executeLambdaDeletion handles Lambda function deletion
func executeLambdaDeletion(ctx context.Context, configPath string) error {
	// Load Lambda configuration
	data, err := os.ReadFile(configPath)
	if err != nil {
		return fmt.Errorf("failed to read configuration file: %w", err)
	}

	var lambdaConfig config.LambdaFunctionConfig

	// Parse TOML configuration
	if err := toml.Unmarshal(data, &lambdaConfig); err != nil {
		return fmt.Errorf("failed to parse Lambda configuration: %w", err)
	}

	functionName := lambdaConfig.Metadata.Name

	if dryRunFlag {
		fmt.Printf("================================================================================\n")
		fmt.Printf("DRY RUN: Lambda Function Deletion Plan\n")
		fmt.Printf("Configuration: %s\n", configPath)
		fmt.Printf("================================================================================\n\n")

		fmt.Printf("FUNCTION TO DELETE:\n")
		fmt.Printf("  Type:     AWS Lambda Function\n")
		fmt.Printf("  Name:     %s\n", functionName)
		fmt.Printf("  Runtime:  %s\n", lambdaConfig.Metadata.Runtime)
		fmt.Printf("  Handler:  %s\n\n", lambdaConfig.Metadata.Handler)

		fmt.Printf("ACTIONS THAT WOULD BE PERFORMED:\n")
		actionCount := 1
		fmt.Printf("  %d. Delete Lambda function: %s\n", actionCount, functionName)
		actionCount++

		if lambdaConfig.Layer != nil {
			fmt.Printf("  %d. Delete associated layer: %s\n", actionCount, lambdaConfig.Layer.Name)
			actionCount++
		}

		if lambdaConfig.IAM != nil && lambdaConfig.IAM.AutoCleanup && lambdaConfig.IAM.ManagedBy == "genesys" {
			fmt.Printf("  %d. Delete IAM role: %s (Genesys-managed)\n", actionCount, lambdaConfig.IAM.RoleName)
			actionCount++
		}

		if lambdaConfig.Deployment.FunctionURL {
			fmt.Printf("  %d. Remove function URL configuration\n", actionCount)
			actionCount++
		}

		if len(lambdaConfig.Triggers) > 0 {
			fmt.Printf("  %d. Remove %d trigger(s)\n", actionCount, len(lambdaConfig.Triggers))
		}

		fmt.Printf("\n⚠️  WARNING: This action is IRREVERSIBLE!\n")
		fmt.Printf("   The function and its configuration will be permanently lost.\n")

		fmt.Printf("\n================================================================================\n")
		fmt.Printf("No actual changes will be made. Use 'genesys execute deletion %s' to proceed.\n", configPath)
		fmt.Printf("================================================================================\n")
		return nil
	}

	fmt.Printf("================================================================================\n")
	fmt.Printf("APPLYING: Lambda Function Deletion\n")
	fmt.Printf("Configuration: %s\n", configPath)
	fmt.Printf("================================================================================\n\n")

	fmt.Printf("[WARNING] Deleting Lambda Function:\n")
	fmt.Printf("  Name:     %s\n", functionName)
	fmt.Printf("  Runtime:  %s\n", lambdaConfig.Metadata.Runtime)
	fmt.Printf("  Handler:  %s\n\n", lambdaConfig.Metadata.Handler)

	fmt.Printf("This action cannot be undone!\n")
	fmt.Println("Proceeding with deletion...")

	// Check AWS credentials
	interactiveConfig, err := config.NewInteractiveConfig()
	if err != nil {
		return fmt.Errorf("failed to initialize configuration: %w", err)
	}

	_, err = interactiveConfig.LoadProviderConfig("aws")
	if err != nil {
		return fmt.Errorf("AWS not configured. Run 'genesys config setup' to configure AWS credentials")
	}

	// Create AWS provider - determine region
	region := "us-east-1" // Default region for Lambda
	if awsConfig, err := interactiveConfig.LoadProviderConfig("aws"); err == nil {
		if awsConfig.Region != "" {
			region = awsConfig.Region
		}
	}

	provider, err := aws.NewAWSProvider(region)
	if err != nil {
		return fmt.Errorf("failed to create AWS provider: %w", err)
	}

	// Get serverless service
	serverlessService := provider.Serverless()

	// Step 1: Delete Lambda function
	fmt.Printf("Step 1/3: Deleting Lambda function...\n")
	err = serverlessService.DeleteFunction(ctx, functionName)
	if err != nil {
		fmt.Printf("  ⚠️  Failed to delete Lambda function: %v\n", err)
		fmt.Printf("  (Continuing with cleanup of other resources...)\n")
	} else {
		fmt.Printf("  ✓ Lambda function deleted: %s\n", functionName)
	}

	// Step 2: Delete layer if it exists and is managed by us
	if lambdaConfig.Layer != nil {
		fmt.Printf("Step 2/3: Deleting Lambda layer...\n")
		layerName := lambdaConfig.Layer.Name

		// Attempt to delete the layer - skip for now as DeleteLayer is not implemented
		fmt.Printf("  ℹ️  Layer cleanup skipped (layer deletion not implemented): %s\n", layerName)
	} else {
		fmt.Printf("Step 2/3: No layer to delete\n")
	}

	// Step 3: Clean up IAM role if managed by Genesys
	fmt.Printf("Step 3/3: Cleaning up IAM role...\n")
	if lambdaConfig.IAM != nil && lambdaConfig.IAM.AutoCleanup && lambdaConfig.IAM.ManagedBy == "genesys" {
		iamService := provider.IAM()
		roleName := lambdaConfig.IAM.RoleName

		if err := cleanupIAMRole(ctx, iamService, roleName); err != nil {
			fmt.Printf("  ⚠️  Failed to clean up IAM role %s: %v\n", roleName, err)
		} else {
			fmt.Printf("  ✓ IAM role cleaned up: %s\n", roleName)
		}
	} else {
		fmt.Printf("  ℹ️  IAM role cleanup skipped (external or auto-cleanup disabled)\n")
	}

	// Remove from local state - skip as state management is not implemented
	// Note: Local state cleanup would be implemented here when state management is added

	fmt.Printf("\n================================================================================\n")
	fmt.Printf("SUCCESS: Lambda Function and Resources Deleted\n")
	fmt.Printf("================================================================================\n\n")

	fmt.Printf("RESOURCES DELETED:\n")
	fmt.Printf("  Function Name: %s\n", functionName)
	fmt.Printf("  Runtime:       %s\n", lambdaConfig.Metadata.Runtime)
	fmt.Printf("  Region:        %s\n", region)
	if lambdaConfig.Layer != nil {
		fmt.Printf("  Layer:         %s\n", lambdaConfig.Layer.Name)
	}
	if lambdaConfig.IAM != nil && lambdaConfig.IAM.ManagedBy == "genesys" {
		fmt.Printf("  IAM Role:      %s\n", lambdaConfig.IAM.RoleName)
	}

	fmt.Printf("\nThe Lambda function and all its configurations have been permanently removed.\n")
	fmt.Printf("This action cannot be undone.\n")
	fmt.Printf("\n================================================================================\n")

	return nil
}

// performEC2DryRun performs actual AWS API validation for EC2 dry-run
func performEC2DryRun(ctx context.Context, configPath string, ec2Config config.EC2InstanceConfig) error {
	fmt.Printf("================================================================================\n")
	fmt.Printf("PREVIEW: EC2 Instance Creation Plan\n")
	fmt.Printf("Configuration: %s\n", configPath)
	fmt.Printf("================================================================================\n\n")

	instanceName := ec2Config.Resources.Compute[0].Name

	fmt.Printf("RESOURCE TO CREATE:\n")
	fmt.Printf("  Type:         AWS EC2 Instance\n")
	fmt.Printf("  Name:         %s\n", instanceName)
	fmt.Printf("  Region:       %s\n", ec2Config.Region)
	fmt.Printf("  Instance Type: %s\n", ec2Config.Resources.Compute[0].Type)
	fmt.Printf("  AMI:          %s\n", ec2Config.Resources.Compute[0].Image)

	fmt.Printf("\nVALIDATION RESULTS:\n")
	validationErrors := []string{}

	// Create AWS provider to validate
	provider, err := aws.NewAWSProvider(ec2Config.Region)
	if err != nil {
		validationErrors = append(validationErrors, fmt.Sprintf("AWS Provider: Failed to initialize (%v)", err))
	} else {
		fmt.Printf("  ✓ AWS Provider: Initialized successfully\n")

		// Validate credentials
		computeService := provider.Compute()

		// Test credentials by trying to list instances (this validates auth)
		fmt.Printf("  → Testing AWS credentials...\n")
		_, err := computeService.ListInstances(ctx, map[string]string{})
		if err != nil {
			validationErrors = append(validationErrors, fmt.Sprintf("AWS Credentials: Invalid or insufficient permissions (%v)", err))
		} else {
			fmt.Printf("  ✓ AWS Credentials: Valid and authenticated\n")
		}

		// Validate AMI
		fmt.Printf("  → Resolving and validating AMI...\n")

		// Initialize AMI resolver
		if computeService := provider.Compute(); computeService != nil {
			// Use reflection to access private method - let's use the actual creation flow
			amiID, err := validateAMIAccess(ctx, provider, ec2Config.Resources.Compute[0].Image, ec2Config.Region)
			if err != nil {
				validationErrors = append(validationErrors, fmt.Sprintf("AMI Resolution: %v", err))
			} else {
				fmt.Printf("  ✓ AMI: Resolved to %s and accessible\n", amiID)
			}
		}

		// Validate instance type (simplified check for known types)
		fmt.Printf("  → Validating instance type...\n")
		instanceType := ec2Config.Resources.Compute[0].Type
		knownTypes := []string{"t2.micro", "t3.micro", "t3.nano", "t3.small", "t3.medium", "t3.large", "t3.xlarge", "c7i-flex.large", "m7i-flex.large", "small", "medium", "large", "xlarge"}
		isKnownType := false
		for _, kt := range knownTypes {
			if instanceType == kt {
				isKnownType = true
				break
			}
		}
		if !isKnownType {
			validationErrors = append(validationErrors, fmt.Sprintf("Instance Type: '%s' is not a recognized instance type", instanceType))
		} else {
			fmt.Printf("  ✓ Instance Type: %s is a valid instance type\n", instanceType)
		}
	}

	// Show configuration details
	fmt.Printf("\nCONFIGURATION DETAILS:\n")
	fmt.Printf("  Public IP:    %s\n", formatBool(ec2Config.Resources.Compute[0].PublicIP, "Assigned", "None"))
	if ec2Config.Resources.Compute[0].KeyPair != "" {
		fmt.Printf("  Key Pair:     %s\n", ec2Config.Resources.Compute[0].KeyPair)
	}
	if ec2Config.Resources.Compute[0].Storage != nil {
		fmt.Printf("  Storage Size: %d GB\n", ec2Config.Resources.Compute[0].Storage.Size)
		fmt.Printf("  Volume Type:  %s\n", ec2Config.Resources.Compute[0].Storage.VolumeType)
		fmt.Printf("  Encrypted:    %s\n", formatBool(ec2Config.Resources.Compute[0].Storage.Encrypted, "Yes", "No"))
	}

	if len(ec2Config.Resources.Compute[0].Tags) > 0 {
		fmt.Printf("\nRESOURCE TAGS:\n")
		for k, v := range ec2Config.Resources.Compute[0].Tags {
			fmt.Printf("  %-15s: %s\n", k, v)
		}
	}

	// Show validation summary
	fmt.Printf("\n%s\n", strings.Repeat("=", 80))
	if len(validationErrors) == 0 {
		fmt.Printf("VALIDATION STATUS: ✓ ALL CHECKS PASSED\n")
		fmt.Printf("This configuration is ready for deployment.\n")
	} else {
		fmt.Printf("VALIDATION STATUS: ✗ %d ERROR(S) FOUND\n", len(validationErrors))
		fmt.Printf("The following issues must be resolved before deployment:\n")
		for i, err := range validationErrors {
			fmt.Printf("  %d. %s\n", i+1, err)
		}
	}

	// Add cost estimate
	fmt.Printf("\n%s\n", strings.Repeat("=", 80))
	if estimate, err := config.EstimateEC2Costs(ec2Config.Resources.Compute[0], ec2Config.Region); err == nil {
		fmt.Println(estimate.FormatCostEstimate())
	} else {
		fmt.Printf("Cost estimate unavailable: %v\n", err)
	}

	fmt.Printf("%s\n", strings.Repeat("=", 80))
	if len(validationErrors) == 0 {
		fmt.Printf("No changes made. Use --apply to create the resources:\n")
		fmt.Printf("  genesys execute %s --apply\n", configPath)
	} else {
		fmt.Printf("Fix the validation errors above, then try again.\n")
	}
	fmt.Printf("================================================================================\n")

	return nil
}

// validateAMIAccess validates that the AMI can be resolved and is accessible
func validateAMIAccess(ctx context.Context, provider *aws.AWSProvider, image, region string) (string, error) {
	client, err := provider.CreateClient("ec2")
	if err != nil {
		return "", fmt.Errorf("failed to create EC2 client: %w", err)
	}

	resolver := aws.NewAMIResolver(provider, region)
	amiID, err := resolver.ResolveAMI(ctx, image)
	if err != nil {
		return "", fmt.Errorf("failed to resolve AMI '%s': %w", image, err)
	}

	// Additional validation: verify the AMI exists and is accessible
	params := map[string]string{
		"Action":    "DescribeImages",
		"ImageId.1": amiID,
	}

	resp, err := client.Request("POST", "/", params, nil)
	if err != nil {
		return "", fmt.Errorf("failed to validate AMI access: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", fmt.Errorf("AMI %s not accessible (status: %d)", amiID, resp.StatusCode)
	}

	return amiID, nil
}

// validateInstanceType validates that the instance type is available in the region
func validateInstanceType(ctx context.Context, provider *aws.AWSProvider, instanceType, region string) error {
	client, err := provider.CreateClient("ec2")
	if err != nil {
		return fmt.Errorf("failed to create EC2 client: %w", err)
	}

	// Map the friendly name to AWS instance type
	var actualInstanceType string
	switch instanceType {
	case "small":
		actualInstanceType = "t3.small"
	case "medium":
		actualInstanceType = "t3.medium"
	case "large":
		actualInstanceType = "t3.large"
	case "xlarge":
		actualInstanceType = "t3.xlarge"
	case "t2.micro", "t3.micro", "t3.nano", "t2.small", "c7i-flex.large", "m7i-flex.large":
		actualInstanceType = instanceType
	default:
		actualInstanceType = "t3.micro" // Default
	}

	// Try to describe the instance type
	params := map[string]string{
		"Action":          "DescribeInstanceTypes",
		"InstanceTypes.1": actualInstanceType,
		"MaxResults":      "1",
	}

	resp, err := client.Request("POST", "/", params, nil)
	if err != nil {
		return fmt.Errorf("failed to validate instance type: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("instance type %s not available in region %s", actualInstanceType, region)
	}

	return nil
}

// formatBool formats a boolean value with custom true/false labels
func formatBool(value bool, trueLabel, falseLabel string) string {
	if value {
		return trueLabel
	}
	return falseLabel
}

// ensureIAMRoleAutomated ensures the IAM role exists with no user interaction
func ensureIAMRoleAutomated(ctx context.Context, provider *aws.AWSProvider, iamConfig *config.LambdaIAM, functionName, configPath string) (string, error) {
	// If no IAM config, use defaults
	if iamConfig == nil {
		iamConfig = &config.LambdaIAM{
			RoleName:         fmt.Sprintf("genesys-lambda-%s", functionName),
			RequiredPolicies: []string{"Basic CloudWatch Logs access"},
			AutoManage:       true,
			AutoCleanup:      true,
		}
	}

	iamService := provider.IAM()
	roleName := iamConfig.RoleName

	// Check if role exists
	existingRole, err := iamService.GetRole(ctx, roleName)
	if err == nil {
		// Role exists - validate and update if needed
		fmt.Printf("  ✓ Found existing role: %s\n", roleName)
		return handleExistingRole(ctx, iamService, existingRole, iamConfig)
	}

	if !aws.IsRoleNotFoundError(err) {
		return "", fmt.Errorf("error checking role: %w", err)
	}

	// Role doesn't exist - create it
	fmt.Printf("  Creating role: %s\n", roleName)
	roleArn, err := createRoleAutomated(ctx, iamService, iamConfig, roleName, functionName)
	if err != nil {
		return "", err
	}

	// Update config file with created role ARN
	if err := updateConfigWithRoleArn(configPath, iamConfig, roleArn); err != nil {
		fmt.Printf("  ⚠️ Warning: Failed to update config file with role ARN: %v\n", err)
	}

	return roleArn, nil
}

// createRoleAutomated creates a new IAM role with all required policies
func createRoleAutomated(ctx context.Context, iamService *aws.IAMService, config *config.LambdaIAM, roleName, functionName string) (string, error) {
	// Create role
	roleConfig := &aws.RoleConfig{
		Name:        roleName,
		Description: fmt.Sprintf("Auto-created by Genesys for Lambda: %s", functionName),
		TrustPolicy: aws.GetLambdaTrustPolicy(),
		Tags: map[string]string{
			"ManagedBy": "genesys",
			"Function":  functionName,
		},
	}

	role, err := iamService.CreateRole(ctx, roleConfig)
	if err != nil {
		return "", fmt.Errorf("failed to create role: %w", err)
	}

	fmt.Printf("  ✓ Created role: %s\n", roleName)

	// Attach required policies
	policyARNs := aws.ConvertRequirementsToARNs(config.RequiredPolicies)
	for _, policyARN := range policyARNs {
		if err := iamService.AttachPolicy(ctx, roleName, policyARN); err != nil {
			return "", fmt.Errorf("failed to attach policy %s: %w", policyARN, err)
		}
		fmt.Printf("  ✓ Attached policy: %s\n", aws.ExtractPolicyName(policyARN))
	}

	return role.ARN, nil
}

// handleExistingRole validates and updates an existing role
func handleExistingRole(ctx context.Context, iamService *aws.IAMService, role *aws.Role, config *config.LambdaIAM) (string, error) {
	// Check if role is managed by Genesys
	if role.Tags["ManagedBy"] != "genesys" {
		// External role - just validate it exists
		fmt.Printf("  ℹ️  Using external role (not managed by Genesys)\n")
		return role.ARN, nil
	}

	// Genesys-managed role - update if needed
	currentPolicies, err := iamService.ListAttachedPolicies(ctx, role.Name)
	if err != nil {
		return "", fmt.Errorf("failed to list current policies: %w", err)
	}

	requiredPolicyARNs := aws.ConvertRequirementsToARNs(config.RequiredPolicies)

	// Attach missing policies
	for _, requiredARN := range requiredPolicyARNs {
		found := false
		for _, current := range currentPolicies {
			if current.ARN == requiredARN {
				found = true
				break
			}
		}

		if !found {
			fmt.Printf("  Adding missing policy: %s...\n", aws.ExtractPolicyName(requiredARN))
			if err := iamService.AttachPolicy(ctx, role.Name, requiredARN); err != nil {
				fmt.Printf("  ⚠️ Failed to attach %s: %v\n", requiredARN, err)
			} else {
				fmt.Printf("  ✓ Attached: %s\n", aws.ExtractPolicyName(requiredARN))
			}
		}
	}

	return role.ARN, nil
}

// updateConfigWithRoleArn updates the TOML config file with the created role ARN
func updateConfigWithRoleArn(configPath string, iamConfig *config.LambdaIAM, roleArn string) error {
	// Read existing TOML
	data, err := os.ReadFile(configPath)
	if err != nil {
		return err
	}

	var lambdaConfig config.LambdaFunctionConfig
	if err := toml.Unmarshal(data, &lambdaConfig); err != nil {
		return err
	}

	// Update IAM section
	if lambdaConfig.IAM == nil {
		lambdaConfig.IAM = iamConfig
	}
	lambdaConfig.IAM.RoleArn = roleArn
	lambdaConfig.IAM.ManagedBy = "genesys"

	// Write back to file
	var buf bytes.Buffer
	encoder := toml.NewEncoder(&buf)
	if err := encoder.Encode(lambdaConfig); err != nil {
		return err
	}

	return os.WriteFile(configPath, buf.Bytes(), 0644)
}

// extractRoleName extracts the role name from its ARN
func extractRoleName(roleArn string) string {
	parts := strings.Split(roleArn, "/")
	if len(parts) > 0 {
		return parts[len(parts)-1]
	}
	parts = strings.Split(roleArn, ":")
	if len(parts) >= 6 {
		return strings.TrimPrefix(parts[5], "role/")
	}
	return roleArn
}

// cleanupIAMRole deletes a Genesys-managed IAM role and its attached policies
func cleanupIAMRole(ctx context.Context, iamService *aws.IAMService, roleName string) error {
	// Get role to check if it's managed by Genesys
	role, err := iamService.GetRole(ctx, roleName)
	if err != nil {
		if aws.IsRoleNotFoundError(err) {
			// Role doesn't exist, nothing to clean up
			return nil
		}
		return fmt.Errorf("failed to get role: %w", err)
	}

	// Only delete if it's managed by Genesys
	if role.Tags["ManagedBy"] != "genesys" {
		return fmt.Errorf("role is not managed by Genesys, skipping deletion")
	}

	// Detach all managed policies
	attachedPolicies, err := iamService.ListAttachedPolicies(ctx, roleName)
	if err != nil {
		return fmt.Errorf("failed to list attached policies: %w", err)
	}

	for _, policy := range attachedPolicies {
		if err := iamService.DetachPolicy(ctx, roleName, policy.ARN); err != nil {
			return fmt.Errorf("failed to detach policy %s: %w", policy.ARN, err)
		}
	}

	// Delete the role
	if err := iamService.DeleteRole(ctx, roleName); err != nil {
		return fmt.Errorf("failed to delete role: %w", err)
	}

	return nil
}
